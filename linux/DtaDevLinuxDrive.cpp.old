/* C:B**************************************************************************
   This software is Copyright (c) 2014-2024 Bright Plaza Inc. <drivetrust@drivetrust.com>

   This file is part of sedutil.

   sedutil is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   sedutil is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with sedutil.  If not, see <http://www.gnu.org/licenses/>.

   * C:E********************************************************************** */

#include <cstdint>
#include <cstring>
#include <algorithm>
#include "dirent.h"
#include "os.h"
#include "log.h"
#include "DtaEndianFixup.h"
#include "DtaHexDump.h"
#include "DtaDevLinuxDrive.h"

#include "ParseDiscovery0Features.h"

/**
 *
 * Static class members of DtaDevOSDrive that are passed through
 * to DtaDevLinuxDrive
 *
 */


bool DtaDevOSDrive::isDtaDevOSDriveDevRef(const char * devref) {
  return DtaDevLinuxDrive::isDtaDevLinuxDriveDevRef(devref);
}

std::vector<std::string> DtaDevOSDrive::enumerateDtaDevOSDriveDevRefs() {
  return DtaDevLinuxDrive::enumerateDtaDevLinuxDriveDevRefs();
}

DtaDevOSDrive * DtaDevOSDrive::getDtaDevOSDrive(const char * devref,
                                                DTA_DEVICE_INFO &disk_info)
{
  return static_cast<DtaDevOSDrive *>(DtaDevLinuxDrive::getDtaDevLinuxDrive(devref, disk_info));
}


OSDEVICEHANDLE DtaDevOSDrive::openDeviceHandle(const char* devref) {
  return DtaDevLinuxDrive::openDeviceHandle(devref);
}

void DtaDevOSDrive::closeDeviceHandle(OSDEVICEHANDLE osDeviceHandle) {
  DtaDevLinuxDrive::closeDeviceHandle(osDeviceHandle);
}


OSDEVICEHANDLE DtaDevLinuxDrive::openAndCheckDeviceHandle(const char * devref)
{
  if (access(devref, R_OK | W_OK)) {
    LOG(E) << "You do not have permission to access the raw device in write mode";
    LOG(E) << "Perhaps you might try sudo to run as root";
  }

  OSDEVICEHANDLE osDeviceHandle = openDeviceHandle(devref);

  if (handleDescriptor(osDeviceHandle) < 0) {
    LOG(E) << "Error opening device " << devref << " " << (int32_t) handleDescriptor(osDeviceHandle);
    //        if (-EPERM == (int)osDeviceHandle) {
    //            LOG(E) << "You do not have permission to access the raw disk in write mode";
    //            LOG(E) << "Perhaps you might try sudo to run as root";
    //        }
  }
  return osDeviceHandle;
}


OSDEVICEHANDLE DtaDevLinuxDrive::openDeviceHandle(const char* devref) {
  return handle(open(devref, O_RDWR));
}

void DtaDevLinuxDrive::closeDeviceHandle(OSDEVICEHANDLE osDeviceHandle) {
  close(handleDescriptor(osDeviceHandle));
}

std::vector<std::string> DtaDevLinuxDrive::enumerateDtaDevLinuxDriveDevRefs()
{
    std::vector<std::string> devrefs;

  DIR *dir = opendir("/dev");
  if (dir==NULL) {
    LOG(E) << "Can't read /dev ?!";
    return devrefs;
  }

  struct dirent *dirent;
  while (NULL != (dirent=readdir(dir))) {
    // char devref[261];
    // snprintf(devref,sizeof(devref),"/dev/%s",dirent->d_name);
    // devrefs.push_back(std::string(devref));
    devrefs.push_back(std::string("/dev/")+dirent->d_name);
  }

  closedir(dir);

  std::sort(devrefs.begin(),devrefs.end());

  return devrefs;
}

uint8_t DtaDevLinuxDrive::discovery0(DTA_DEVICE_INFO & disk_info) {
  void * d0Response = alloc_aligned_MIN_BUFFER_LENGTH_buffer();
  if (d0Response == NULL)
      return DTAERROR_COMMAND_ERROR;
  memset(d0Response, 0, MIN_BUFFER_LENGTH);

  int lastRC = sendCmd(IF_RECV, 0x01, 0x0001, d0Response, MIN_BUFFER_LENGTH);
  if ((lastRC ) != 0) {
    LOG(D4) << "Acquiring Discovery 0 response failed " << lastRC;
    return DTAERROR_COMMAND_ERROR;
  }
  parseDiscovery0Features((uint8_t *)d0Response, disk_info);
  free_aligned_MIN_BUFFER_LENGTH_buffer(d0Response);
  return DTAERROR_SUCCESS;
}
